Title: Socket.IO for backend developers
Tags: Perl
Comments: no

There is an official Socket.IO specification document, but it doesn't tell you
the implementation details of every transport. When implementing a server side
of Socket.IO you have to use C<tcpdump> or C<wireshark> to capture packets
and actually see what you have to send and receive. So here are the details that
I collected when implementing L<http://github.com/vti/pocketio>.

[cut]

First, read the specification L<https://github.com/learnboost/socket.io-spec>.

=head1 Handshake

In order to make some browser debug tools like Firebug happy specify a correct
C<Content-Type> for the handshake response. I set C<text/plain>.

    HTTP/1.1 200 OK
    Content-Type: text/plain
    Connection: keep-alive
    Content-Length: 73

    1234567890:15:25:websocket,flashsocket,htmlfile,xhr-polling,jsonp-polling

=head2 Tranport priority

The recommented transport priority is:

    websocket,flashsocket,htmlfile,xhr-polling,jsonp-polling

=head2 Cross-Domain connections

When you want to run your Socket.IO server on a different port or domain from
the main website, you have to make sure it supports cross-domain jsonp calls.

So on this handshake request:

    GET /socket.io/1/?t=1312877027739&jsonp=0 HTTP/1.1
    Host: localhost:5000
    Connection: keep-alive

you should response with:

    HTTP/1.1 200 OK
    Content-Type: application/javascript
    Content-Length: 90

    io.j[0]("1234567890:15:25:websocket,flashsocket,htmlfile,xhr-polling,jsonp-polling");

C<0> is from request C<jsonp=0> query string.

Every next response should contain the following header:

    Access-Control-Allow-Origin: *

=head1 Flash policy server

When using a Flash fallback you must run a Flash policy server
(L<https://github.com/keroyonn/p5-AnyEvent-FlashSocketPolicy> or
L<https://github.com/vti/pocketio/blob/master/examples/flash-policy-server>).
This can be a standalone server that listens on C<843> port (must be run as
root) or an inline server that answers not only C<HTTP> but also Flash requests
(L<Fliggy>).

=head1 Transports

Now you know how to do a handshake, how to parse and build messages. As you
already know we have to implement the following transports:

    WebSocket
    Flashsocket
    XHR Polling
    XHR Multipart
    Htmlfile
    JSONP polling

C<WebSocket> and C<Flashsocket> are easy, just use L<Protocol::WebSocket> for
parsing C<WebSocket> handshake and frames. These two transports are exactly the
same on the server side.

C<XHR Multipart> is disabled in the latest Socket.IO version. I haven't really
dug into this problem, but I hope it will be reenabled in the next versions
(AFAIK it affects only Firefox 3.x, but you can still use C<XHR Polling> there).

So we are left with C<XHR Polling>, C<JSONP Polling> and C<Htmlfile>. These
transports are unidirectional. This means we have to use one channel for sending
messages and one channel for receiving them. Moreover the server channel is a
C<GET> request with a delayed response (C<XHR Polling> and C<JSONP Polling>) or
streaming response (C<Htmlfile>) and the client channel is a sequence of C<POST>
requests with simple confirmation responses.

C<XHR Polling> and C<JSONP Polling> transports reconnect after the message from
the server to the client was sent. So you have to cache the messages that are
sent during reconnection and then send them sequentially when the connection is
established.

A detailed explanation of every transport follows.

=head2 XHR Polling

=head3 Server -> Client

When C<XHR Polling> connection is established a C<GET> request is made awaiting
for a delayed response from the server.

    GET /socket.io/1/xhr-polling/15725592722050266739/?t=1312200210467 HTTP/1.1
    Host: 127.0.0.1:5000
    Connection: Keep-Alive

When the server wants to send a message it responses with something like:

    HTTP/1.1 200 OK
    Content-Type: text/plain
    Content-Length: 47

    5:::{"args":[{"vti":"vti"}],"name":"nicknames"}

and closes the connection. It could be a chunked response by the way.

=head3 Client -> Server

When a client wants to send a message it creates a C<POST> request:

    POST /socket.io/1/xhr-polling/15725592722050266739?t1312200250539 HTTP/1.1
    Host: 127.0.0.1:5000
    Content-Length: 45
    Connection: Keep-Alive

    5:::{"name":"user message","args":["hello!"]}

And should receive a simple C<200> response from the server:

    HTTP/1.0 200 OK
    Content-Length: 1

    1

=head2 JSONP Polling

C<JSONP Polling> is similar to C<XHR Polling>. You just have to wrap messages
into C<JavaScript>.

=head3 Server -> Client

The server channel is created as a C<GET> request awaiting for a delayed response:

    GET /socket.io/1/jsonp-polling/4168417008084729/?t=1312874409449&i=0 HTTP/1.1
    Host: localhost:5000
    Connection: keep-alive

When the server wants to send a message it responses with (notice the correct
C<Content-Type>):

    HTTP/1.1 200 OK^M
    Content-Type: text/javascript; charset=UTF-8
    Content-Length: 69

    io.j[0]("5:::{\"args\":[{\"vti\":\"vti\"}],\"name\":\"nicknames\"}");

And closes the connection. Noticed C<io.j[0]("a message goes here")>? Don't forget
to escape quotes when wrapping your message.

=head3 Client -> Server

When a client wants to send a message it makes a C<POST> request:

    POST /socket.io/1/jsonp-polling/4168417008084729?t=1312874410509&i=0 HTTP/1.1
    Host: localhost:5000
    Connection: keep-alive
    Content-Type: application/x-www-form-urlencoded
    Content-Length: 85

    d=5%3A%3A%3A%7B%22name%22%3A%22user+message%22%2C%22args%22%3A%5B%22hello%21%22%5D%7D

As you can see the request now is C<x-www-form-urlencoded> with a C<d> parameter
with encoded message. Don't forget to decode the message on the server.

And the client should receive a simple C<200> response from the server:

    HTTP/1.0 200 OK
    Content-Length: 1

    1

=head2 Htmlfile

C<Htmlfile> is a tranport for Internet Explorer (read "some nasty hacks
follow").

=head3 Server -> Client

The server channel is created as a C<GET> request and a streaming response
(server does not close the connection when sending a message to the client, it
just pushes it):

    GET /socket.io/1/htmlfile/4168417008084729/?t=1312874409449 HTTP/1.1
    Host: localhost:5000
    Connection: keep-alive

The server responses with a chunked streaming response:

    HTTP/1.1 200 OK
    Content-Type: text/html
    Connection: keep-alive
    Transfer-Encoding: chunked

    100
    <html><body><script>var _ = function (msg) { parent.s._(msg, document); };</script>

Followed by C<173> spaces (I am sure you can google why) and an empty line.

When the server wants to send a message it pushes a chunk to the stream:

    50
    <script>_("5:::{\"args\":[{\"vti\":\"vti\"}],\"name\":\"nicknames\"}");</script>

You have to wrap your message into C<script> tags and C<_("your messages")>
function. Don't forget to escape quotes.

=head3 Client -> Server

When a client wants to send a message it makes a C<POST> request:

    POST /socket.io/1/xhr-polling/15725592722050266739?t1312200250539 HTTP/1.1
    Host: 127.0.0.1:5000
    Content-Length: 45
    Connection: Keep-Alive

    5:::{"name":"user message","args":["hello!"]}

And the client should receive a simple C<200> response from the server:

    HTTP/1.0 200 OK
    Content-Length: 1

    1

=head1 Horizontal scaling

When using Nginx with C<tcp_proxy_module>
(L<https://github.com/yaoweibin/nginx_tcp_proxy_module>) for proxying Socket.IO
connections (how to setup read more at
L<http://www.letseehere.com/reverse-proxy-web-sockets>) you can't be sure that
the next request will come to the same process and thus you have to make sure
different processes can communicate, exchanging connections, sending broadcast
mesages etc (more at
L<http://stackoverflow.com/questions/5944714/how-can-i-scale-socket-io>).

The guys who made Socket.IO have a cluster solution
L<http://learnboost.github.com/cluster/> for NodeJS. Maybe this can be brought
into Perl too.

Scaling support for PocketIO is on the roadmap.

=head1 Comments

If you found any error or something is not detailed enough, fill free to
comment below.
